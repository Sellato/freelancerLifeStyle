/* УРОК №8 https://youtu.be/l9bqp5kUWW8 */
/* 
&display=swap
&subset=cyrillic-ext 
*/
@import url("https://fonts.googleapis.com/css?family=Roboto:100,100italic,300,300italic,regular,italic,500,500italic,700,700italic,900,900italic");

/* ОБНУЛЕНИЕ СТИЛЕЙ */
*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
	box-sizing: border-box;
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html,
body {
	height: 100%;
}
html {
	font-size: 16px; /* по умолчанию */
}
body {
	line-height: 1;
	/* color: #000; */
	/* font-family:""; */
	font-family: "Roboto";
	font-size: 30px;
}
.wrapper {
	min-height: 100%;
	overflow: hidden;
}
/* ------------------------------ */
.block {
	padding: 30px;
	display: inline-block;
	background-color: #7a956b;
	margin: 0px 0px 20px 0px;
}
/* Псевдоэлементы и псевдоклассы (фундаментальная тема)*/

.link {
	color: yellow;
}

/* Псевдоклассы */
/* Псевдоклассы состояния */
/* ======================================================= */
/* :visited 
 Срабатывает для посещенных ссылок */
.link:visited {
	color: yellowgreen;
}
/* Соответсвенно стили кот. мы применяем в состояние visited, они смогут пользователю показать (отметить, обозначить) те ссылки которые уже посещали.
С точки зрения юзабилити пользования это довольно классная штука. (однако почему то очень крайне редко используют в макетах) */

/* visited работает только для ссылок, потому что посещали ссылку или нет зависит от значения href="#", а href="#" есть только у ссылок */
/* Правильный порядок с visited - это состояние в покое .link, потом visited, потом hover, что бы у нас  hover срабатывал, потом focus, а потом active. В таком порядке мы увидим все
псевдоклассы.*/

/*
Замечание: Из-за причин приватности, 
браузеры строго ограничивают стили, которые вы 
можете применить к элементу, используя этот псевдо-класс:
только color, background-color, border-color,
border-bottom-color, border-left-color, border-right-color,
border-top-color, outline-color, column-rule-color, 
fill и stroke. Заметьте также, что альфа-канал будет 
игнорироваться: будет использоваться альфа-канал, 
используемый для непосещённых ссылок вместо него 
(но если прозрачность - 0, то в этот случае 
игнорируется весь цвет, и один из используемых 
стилей для непосещённых ссылок).
*/
/* ======================================================= */
/* 
:hover
Срабатывает при наведении на элемент, 
часто применяется  как для ссылок так
и для любого другого элемента.
hover поддерживает все стили.
*/
.link:hover {
	color: red;
}
/* --------------------------------------------------------------------------------------------- */
.link {
	color: yellow;
}
.link:hover {
	opacity: 0;
	visibility: hidden;
	color: red;
}
/* Мы наводим курсор и происходит очень быстрое срабатывание и в какой то момент ссылка все таки пропадает - это ошибка и так быть не должно.
Это происходит потому что слушаем состояние hover на объекте, кот. при срабатывании этого состояния мы делаем ему visibility: hidden;(отменяет взаимодействие с этим объектом).
То есть получается мы на него навели - он исчез но эта ошибка появляется потому что объект исчезает и взаимодействие с ним прекращается, соответственно мы не можем на него влиять(мы теряем возможность прослушивать hover на этом объекте)  
Это довольно частое явление когда нам нужно на что то навести что бы оно пропало или на оборот появилось. */

/* или изначально у нас объект скрыт и мы хотим при наведении его показать */
.link {
	color: yellow;
	opacity: 0;
	visibility: hidden;
}
.link:hover {
	opacity: 1;
	visibility: visible;
	color: red;
}
/* Из-за того что у нас изначально 	visibility: hidden; - объект не будет появляться потому что мы не можем на нем прослушать hover, его нет, 
взаимодействие с ним не возможно(visibility: hidden;  как бы оставляет его тело, но выключает с ним взаимодействие соответственно hover мы на нем прослушать не можем и не можем его отобразить). */

/* Решаем проблему (мы можем прослушать родителя любого уровня, не обязательно не посредственного родителя)*/
.block:hover .link {
	display: inline-block;
	opacity: 1;
	visibility: visible;
}
.link {
	color: yellow;
	opacity: 0;
	visibility: hidden;
}
.link:hover {
	color: red; /* теперь будет всё работать, потому что объект кот. изначально скрыт - мы с ним не взаимодействуем, мы взаимодействуем с объектом кот. у нас не скрыт - он здесь, он с нами.  */
}

/* Вложенность. Нам нужно разделить место где мы будем слушать hover и собственно сам объект кот. должен реагировать на наведение.
 Мы будем слушать hover на .block, на этом зеленом родителе, который никуда не исчезает, он у нас есть тут по умолчанию. Соостветственно мы на него вешаем прослушку hover.
 Нам нужно при наведении отобразить ссылку соотсветственно в соостоянии объекта .block:hover мы обращаемся к вложенной в него ссылки  .link. Соотсветственно  .block получает hover при 
 наведении и мы в этот момент обращаемся к ссылке.
 Когда нам нужно взаимодействовать со скрытым объектом - слушайте родителя, вешайте прослушку(hover) на родителя, далее в этом состоянии обращайтесь ко вложенному объекту.
 Не всегда нужно вешать hover на тот объект с кот. должно что то с ним происходить.*/
/*
--------------------------------------------------------------------------------------
Обращение к дочернему элементу, 
при состоянии ("при наведении") родителя 
*/

.block:hover .link {
}

/* ======================================================= */
/*
:focus
Срабатывает при получении элементом фокуса. Довольно редко используется.
По умолчанию применяется ко всем объетам с кот. можно взаимодействовать, на пример с теми же ссылками.
Часто применяется к елементам форм. Например инпутам.
*/

.link:focus {
	color: blue; /* ссылка обромилась каким то outline это как раз ссылка получила состояние focus. */
	outline: none;
}
/* outline: 1px solid;или на оборот. */
/* Если мы не даем каких то своих стилей то мы не увидим оригинальный outline. Мы его увидим только при табе. А если мы хотим какие то кастомные вещи делать, 
	то мы к сожалению увидим этот фокус тогда когда начнем взаимодействовать с нашей ссылкой, и не всегда это нужно. */
/* Играет роль порядок, на пример мы  focus поставим перед visited и focus и мы увидим что теперь стиль будут перебивать focus и таким образом и можем каким то чудом избавиться от перекраски.
	То есть мы не будем видеть голубой цвет потому что  порядок мы изменили так как мы поставили focus где то выше. Но при этом focus не будет работать при табе. И самым правильным решение будет поставить его
	после visited - то есть при табе мы увидим то что нам нужно - focus, но по идее при клике(при взаимодейсивии с объектом)   мы увидим наш фокус.
} 
*/

/* ======================================================= */
/*
:active
Срабатывает при нажатии на элемент. 
В основном применяется к ссылкам и кнопкам.
active используется чаще чем visited. Он призван повысить юзабилити. Этот класс срабатывает когда мы непосредственно кликнули на объект
(в зажатом состоянии клавиши мыши срабатавает этот клас, отпускаем клавишу и состояние active пропадает). Этот клин не сильно заметно(мы еле замечаем) так как пользователи в основном кликают быстро.

*/
.link:active {
	color: #000;
}

/* Единственное его преимущество не плохое это мы нашу ссылку немножко преобразуем. */
.button {
	border-radius: 5px;
	padding: 20px 30px;
	color: #fff;
	background-color: yellowgreen;
	box-shadow: 0px 8px 0px rgb(55, 73, 18);
	position: relative;
	top: 0;
}
.button:hover {
	background-color: rgb(172, 228, 61);
}
.button:active {
	top: 4px;
	box-shadow: 0px 4px 0px rgb(55, 73, 18);
}

/* ======================================================= */
/*
:target
target предоставляет возможность к некоторому интерактиву, что свойственно больше для js.
В принцыпе мы его использовать и не будем.
Срабатывает когда элемент является объектом 
на который ссылаются
*/
/* В href мы можем указать некий # и сослаться на некий id.  */
/* Минус target в том что мы будем прокручиваться к этому объекту где бы мы не находились(скрол прокрутится к этому объекту и это не всегда нужно). */
.window {
	padding: 20px;
	color: #fff;
	display: none;
	background-color: #77608d;
}
.window:target {
	display: block; /* объект на кот. мы сослались у кот. есть id одноемённый с # будет получать состояние target.  */
}
/* ======================================================= */
/* ======================================================= */
/* ======================================================= */
/* Псевдоклассы положения в коде */
/* Подразумевают что мы можем из css без каких-то дополнительных вещей в html обращаться к тому или иному объекту 
используя его положение(порядок его вывода) в коде.  */
.text {
	margin: 0px 0px 50px 0px;
}
.text p {
	/* margin: 0px 0px 20px 0px; */
}
.list {
}
.list li {
	margin: 0px 0px 20px 0px;
}

/*
:first-child
:first-child обращается к первому объекту внутри родителя. 
:first-child - это псевдокласс когда объект в состоянии первого внутри родителя.
Обращение к первому элементу в блоке(внутри родителя).
*/

.text p:first-child {
	color: red;
}
/* 
Если перед этим тегом p поставить тег, например span, то мы теряем эту способность.
То есть именно тег p(параграф) он первый, но он не первый ребенок, не первый дочерний элемент. Если перед этим параграфом что то будет то мы теряем эту способность.
*/
/* ======================================================= */
/* :first-of-type */
/* Первый в блоке тег P, даже если выше 
него есть другие теги */

.text p:first-of-type {
	color: red; /* параграф будет красным в независимости от того что перед ним еще есть span */
}
/*
.text p:first-of-type обращается к первому тегу(к первому тегу p) внутри родителя, не к первому объекту как :first-child, а к первому тегу.
*/

/* Любой объект который первый внутри родителя 
 Если нам нужно что бы абсолютно любой, кем бы он не был, если он первый, что б он как то выдилялся. */
/*   * это такой селектор кот. обращается абсолютно ко всем объектам */
.text *:first-child {
	color: red; /* сейчас абсолютно любой объект кот. будет первым, он будет красным */
}

/* ======================================================= */
/*
:last-child
Обращение к последнему элементу в блоке
*/

.text p:last-child {
	color: red;
}
/* ======================================================= */
/* :last-of-type */
/* Последний в блоке тег P, 
если ниже него ничего нет  */

.text p:last-of-type {
	color: red;
}

/* Убираем лишний отступ. Вариант №1 */

.text *:last-child {
	margin-bottom: 0; /* почему именно margin-bottom, а не margin: 0px 0px 0px 0px;, потому что у нас возможная ситуация когда нам не нужно у последнего объекта убирать 
	какие то другие отступы, а только отступ вниз. */
}
/* Пример */

/* ======================================================= */
/*
:nth-child
:nth-child(порядковый номер элемента)
Обращение к конкретным элементам в блоке
*/
/* Соответственно при добавлении каких то объектов это будет дело смещаться(если мы на пример добавим спан в самый верх у родителя),
теперь первый p это второй p. По этому  nth-child при указании конкретной цифры не очень актуален, потому что при изменении контента  это все дело смещается. 
Но это довольно неплохо работает с другими настройками - настройками очередности odd и even*/

/* odd - будет выделяться каждый нечетный объект */
/* even - будет выделяться каждый четный объект  */
.text p:nth-child(odd) {
	color: red;
}

.text p:nth-child(2):hover {
	/* сначала мы находим параграф кот. находится на втором месте в коде, а потом мы вешаем на него прослушку hover */
	color: green;
}
/* ------------------------------------------------------------------------------------------------------------------- */
/* Выбирает каждый четвёртый элемент
   среди любой группы соседних элементов */
:nth-child(4n) {
	color: lime;
}
/* ------------------------------------------------------------------------------------------------------------------- */
/* tr:nth-child(odd) или tr:nth-child(2n+1)
Описывает нечётные строки HTML таблицы: 1, 3, 5, и т. д. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* tr:nth-child(even) or tr:nth-child(2n)
Описывает чётные строки HTML таблицы: 2, 4, 6, и т. д. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* :nth-child(5n)
Описывает элементы с номерами 5, 10, 15, и т. д. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* :nth-child(3n+4)
Описывает элементы с номерами 4, 7, 10, 13, и т. д. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* :nth-child(-n+3)
Описывает первые три элемента среди группы соседних элементов. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* p:nth-child(n)
Описывает каждый элемент<p> среди группы соседних элементов. Эквивалентно простому селектору p. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* p:nth-child(1) или p:nth-child(0n+1)
Описывает каждый элемент <p>, являющийся первым среди группы соседних элементов. Эквивалентно селектору :first-child. */
/* ------------------------------------------------------------------------------------------------------------------- */
/* Убираем лишний отступ. Вариант №2 
 для любых объектов внутри объектов с классом .text
 добавить внешний отступ 20px вниз, 
 но кроме последнего объекта
*/

/* При задавании отступа мы делаем некое условие что у последнего объекта не будет оступа */
.text *:not(:last-child) {
	/*  все кроме last-child */
	margin: 0px 0px 20px 0px;
}

/* ======================================================= */
/* ======================================================= */
/* ======================================================= */
/*
 ::first-line 
Псевдоэлемент ::first-line задает стиль первой 
строки форматированного текста. 
Длина этой строки зависит от многих факторов, 
таких как используемый шрифт, 
размер окна браузера, ширина блока, языка и т.д. 
В правилах стиля допустимо 
использовать только свойства, относящиеся к шрифту, 
изменению цвета текста и фона.
*/
/* Псевдоэлемент принято писать через двоеточие ::  */
.content {
	margin: 0px 0px 30px 0px;
}
.content::first-line {
	/* color: red; */
}
/* ======================================================= */
/* ::first-letter */
/*
Псевдоэлемент ::first-letter определяет стиль первого
 символа в тексте элемента, 
к которому добавляется. 
К этому псевдоэлементу могут применяться только
 стилевые свойства, 
связанные со свойствами шрифта, полями, отступами,
 границами, цветом и фоном.
*/

.content {
	text-indent: 30px;
}
.content::first-letter {
	color: red;
	font-size: 80px;
}
/* ::first-letter для списка ul li не работает */
/* ======================================================= */
/*
::before, ::after 
::before, ::after - СТРОЧНЫЕ !!!!
использование content ОБЯЗАТЕЛЬНО! 

Что бы что то добавить перед или после строки, нам возможно понадобились еще какие то span, div еще какой то html. Псевдоклассы ::before и ::after
они к каждому объекту(тегу) фактически автоматически приплюсовывают еще два ::before и два ::after
*/
/* В ::before и ::after ставятся элементы декора , то что врядли будет меняться */
.title {
	margin: 0px 0px 40px 0px;
	font-size: 40px;
	font-weight: 900;
	display: inline-block;
}
.title::after {
	content: "";
	display: block; /* так как ::after строчный, а у строчный ширина и высота не работают */
	background-color: #34c759;
	height: 2px;
	width: 56px;
	margin: 15px 0px 0px 0px;
}

.content::before {
	content: "";
}
.content::after {
	content: "";
}

.list {
	margin: 0px 0px 30px 0px;
}
.list li {
	padding: 0px 0px 0px 30px;
}
.list li::before {
	content: "";
	width: 20px;
	height: 20px;
	background-color: red;
	display: inline-block;
	vertical-align: top;
	margin: 4px 10px 0px -30px;
	border-radius: 50%;
}

/* ------------------------------------------------------------------------------------------------------------------- */
/* В ::before и ::after выводя картинку через content, мы лишаемся всех возможностей свойства background, а именно background-size, background-position и т.д.
Если мы воводим ее через content то мы фактически выводим ее как фон которым не можем управлять.
content: url("../img/dog_stream.png");  - это уже не фон, а это как изображение, кот. тем не менее выводится через css.  */
/* content: url("../img/dog_stream.png"); - в такой ситуации картинка выводится со своими размерами, с теми размерами с которыми она рождена. Мы не сможем изменить размеры с помощью width и height.  */
.list li::before {
	content: url("../img/dog_stream.png");
	width: 20px;
	height: 20px;
	background-color: red;
	display: inline-block;
	vertical-align: top;
	margin: 4px 10px 0px -30px;
	border-radius: 50%;
}
/* ------------------------------------------------------------------------------------------------------------------- */
/* сначала мы находим объект с псевдоклассом  состояния hover, и потом обращаемся к его псевдоэлементу */
.list li:hover::before {
	background-color: blue;
}
.list li:nth-child(1)::before {
	background-color: blue;
}
/* ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
/* counter(item)  */
/* У нас есть список ol/ul - он нумерованый, но естественно после обнуления мы не видим никаких цифр, они нам нужны. Сейчас решим эту задачу */
.num-list {
	counter-reset: item; /*  она позволяет сбросить нам счетчик. */
	margin: 0px 0px 30px 0px;
}
.num-list li:not(:last-child) {
	margin: 0px 0px 20px 0px;
}
.num-list li::before {
	counter-increment: item; /* говорит о том что как раз в эти псевдоэлементы нужно выводить счетчик 1, 2,3...  */
	content: counter(item) ")";
	display: inline-block;
	vertical-align: top;
	color: red;
	margin: 0px 20px 0px 0px;
}
/* ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
.num-list li::before,
.num-list li::after {
}
/* ====================================================================================================== */
/*
/* ---------------------------------------  Пример очень важно  ------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------- */
/* Пример очень важно*/

/* 2 вариант отступа */
/* одинаковые отступы */
/* Если у нас ситуация немного иная, и отступ у всех объектов на пример 30px(то есть одинаковый то мы используем это .item *:not(:last-child)) */
.item *:not(:last-child) {
	margin-bottom: 30px; /*  то есть мы одновременно и задаем отступ и убираем у последнего объекта. Но если мы поменяем местами объекты то отступ появится, или же чего то не будет или вообще ничего не будет,
	только одно, то отступ у этого заголовка пропадет.  */
}
.item {
}

/* 1 вариант отступа */
/* разные отступы */
.item *:last-child {
	/* Поскольку у нас отступы разные, на приходится их задать сначала каждому объекту по макету, а потом .item *:last-child  таким образом обратиться к любому объекту кот. последний и у него забрать */
	margin-bottom: 0px; /* то есть в данном случаем у любого последнего объекта отступа не будет(лишнего висячего отступа не будет) */
}

.item__title {
	font-size: 50px;
	margin: 0px 0px 30px 0px;
}
.item__text {
	margin: 0px 0px 20px 0px;
}
.item__link {
	/* если вдруг заказчик решит ссылку переместить вверх(поменять местами), то отступ у ссылки будет, и наша верстка не поедет */
	margin: 0px 0px 30px 0px;
	display: inline-block;
}
/* ---------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------- */

/*
.test-list {
}
.test-list li {
	background: url("../img/01.png") top right / 50px no-repeat;
	padding: 0px 60px 0px 0px;
}
.test-list li:not(:last-child) {
	margin: 0px 0px 20px 0px;
}
*/
/*
 Решение домашки №7
Смотреть с 2:42:00    https://youtu.be/l9bqp5kUWW8  
*/
.items {
	background: #02133c;
	padding: 50px 0;
}
.items__container {
	max-width: 1020px;
	margin: 0px auto;
}
.items__list {
	font-size: 0; /* обнуляем фантомные отступы */
	margin: 0px -12px;
}
.item {
	display: inline-block;
	width: 25%; /* так как у нас 4 объекта */
	padding: 0px 12px;
	vertical-align: top;
}
.item__image {
	display: inline-block;
	width: 76px;
	text-align: center;
	vertical-align: top;
}
.item__body {
	padding: 0px 0px 0px 11px;
	vertical-align: top;
	display: inline-block;
}
.item__title {
	color: #c40b0b;
	font-weight: 900;
	font-size: 36px;
	line-height: 42px;
}
.item__text {
	color: #f5f5f5;
	font-size: 16px;
	line-height: 24px;
	max-width: 130px;
}
