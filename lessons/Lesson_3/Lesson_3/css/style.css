/* Браузер читает css-файл с верху-вниз с влева на право */

/* ОБНУЛЕНИЕ СТИЛЕЙ */
/* Обнуление для того что бы мы управляли нашей версткой,
что бы мы как дерижери управляли всем этим , а не что-то
управляло нами(какие то встроенные стили). То есть мы все под чистую стираем 
и с нуля строем только те стили кот. нам нужны. */
*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  border: 0;
}
li {
  list-style: none;
}
a,
a:visited {
  text-decoration: none;
}
/* Почему a:visited и a:hover отдельно?
Потому что если для всего проекта мы хотим навесить на ссылки
что нибудь другое, то мы это можем легко сделать в обнулении 
и теперь этот параметр у нас применится ко всем ссылкам, по этому
мы его вынесли отдельно, потому что часто бывает что нужно для 
всего сайта прям в обнулении это дело поменять (a:hover {text-decoration: underline;}). */
a:hover {
  text-decoration: none;
  text-decoration: underline;
}
/* Цвет у ссылок можно обнулить, но не желательно, 
потому что в последствии нам нужно будет использовать потом 
комбинированый селектор, что бы потом изменить этот цвет,
по этому в обнулениее этот параметр не ставим */
h1,
h2,
h3,
h4,
h5,
h6 {
  font-weight: inherit;
  font-size: inherit;
}
img {
  vertical-align: top;
  /* и наша полоса пропадает(нижняя на фото) */
}

/* --------------- */

/* Анатомия */
/*
css - каскадная таблица стилей

селектор{
	css параметр;
	css параметр;
	...
	css параметр;
}
*/
/* CSS параметр */
/*
css свойство: значение(я) свойства;
*/

/* Селекторы */

/* Селектор тега */
/*
имя тега{
	css параметр;
	css параметр;
	...
	css параметр;
}
*/
/* Пример селектора тега */
p {
  /* Обратились ко ВСЕМ тегам P на странице */
  /* color: red; */
}
span {
  /* Обратились ко ВСЕМ тегам SPAN на странице */
  /* color: green; */
}

/* Селектор класса, начинается с ТОЧКИ */
/*
.имя класса {
	css параметр;
	css параметр;
	...
	css параметр;
}
*/
/* --------------- */

.text {
  /* Обратились ко объектам с классом text на странице */
  /* color: green; */
}
.paragraph {
  /* Обратились ко объектам с классом paragraph на странице */
  /* color: red; */
}
/* --------------- */

/* Селектор ID */
/*
#имя id{
	css параметр;
	css параметр;
	...
	css параметр;
}
*/
#menu {
  /* селектор id - может быть только 1 
  на странице(оно уникально), селектор класс 
  таких же может быть несколько на странице */

  /* color: red; */
}

/* Приоритет */
/* Приоритетность - это какое свойство будет иметь больший вес */

/* 1. Порядок записи, при равнозначных селекторах */

p {
  /* Обратились ко ВСЕМ тегам P на странице */
  /* color: red; */
}

/* Этот приоритетней */
p {
  /* Обратились ко ВСЕМ тегам P на странице */
  /* color: yellowgreen; */
}

.text {
  /* Обратились ко объектам с классом text на странице */
  /* color: green; */
}
/* Этот приоритетней */
.paragraph {
  /* Обратились ко объектам с классом paragraph на странице */
  /* color: red; */
}
/* Тут применится то значение этого css-свойство, кот. 
по коду ниже при условии что приоритетность 
одинаковая(text это селектор класса, paragraph и 
это тоже селектор класса и получается работает 
приоритетность той записи которая банально ниже)  */

/* УТОЧНЕНИЕ */
/* Когда мы начинаем что-то уточнять - приоритетность растет */

/* 2. Селектор класса приоритетней чем селектор тега */

.text {
  /* Обратились ко объектам с классом text на странице */
  /* color: green; */
}
p {
  /* Обратились ко ВСЕМ тегам P на странице */
  /* color: red; */
}

/* Селектор ID - самый приоритетный */

#main-text {
  /* Обратились к объекту c ID main-text на странице */
  /* color: blue; */
}
.text {
  /* Обратились ко ВСЕМ объектам с классом text на странице */
  /* color: green; */
}
p {
  /* Обратились ко ВСЕМ тегам P на странице */
  /* color: red; */
}

/* 3. Уточняем обращением  */

/* Комбинация селекторов */

span.text {
  /* Обратились ко ВСЕМ тегам SPAN с классами и text на странице */

  /* color: red; */
}

.text {
  /* Обратились ко ВСЕМ объектам с классом text на странице */
  /* color: green; */
}

span.blue-text {
  /* Обратились ко ВСЕМ тегам SPAN с классом blue-text на странице */

  /* теперь этот селектор span.text равнозначен этому селектору span.blue-text
  потому что идут комбинация тега и класса, соответственно 
  вкючается приоритетность по порядку записи равнозначный
   селекторов, соовтветственно сработал  span.blue-text */

  /* color: blue; */
}
span.text.blue-text {
  /* Но если  мы уточним несколькими классами (мы сузили поиск, 
  уточнили поиск) тогда будет приоритетность расти. Более тонкое 
  уточнение, к чему мы хотим докопаться - приоритетность растет */
  /* при комбинации селекторов где у нас селектор тега потом классы(много классов или один, либо вообще без тега) никаких пробелов нет */

  /* Обратились ко ВСЕМ тегам SPAN с классами(одновременно) 
  и text и blue-text на странице */
  /* color: red; */
}

/* Вложенность и приоритетность */

/* Вложенность - это когда мы обращаемся по тому или 
иному селектору к вложенным объектам внутри какого-небудь */

/* Приоритеность №1 */
/* Когда мы обращаемся к вложенному селектору 
обязательно ставим пробел  */
div p {
  /* то мы обратимся ко всем div на странице, а точнее ко всем p 
	кот. находятся внутри div */

  /* color: blue; */
}

.content .content__item {
  /* Когда мы обращаемся к вложенному селектору класса
обязательно ставим пробел  */

  /* Обратились ко объектам с классом .content__item но только к тем
	которые находятся внутри любых объектов с классом .content на странице 
	(более узкий поиск чем ниже, соответственно приоритетность выше)*/
  /* color: yellowgreen; */

  /* такая приоритетность будет выше чем если просто 
  обратиться к  .content__item(отдельно к классу) */
}

.content__item {
  /* Обратились ко объектам с классом .content__item */
  /* color: violet; */
}

/* Инлайновый стиль будет имет самый большой приоритет */

/* Прочие селекторы */

/* * - Обращение ко абсолютно ВСЕМ объектам */
* {
  /* color: green; */
  /* абсолютно каждый объект покрасится */
}
/*
  * это такой селектор кот. не относится не к одной группе, 
   это значит что мы обращаемся к любому тегу с любым классом, 
   то есть ко всем объектам на странице.
*/
.content * {
  /* обязательно пробел потому что вложеность */

  /* color: aqua; */

  /* обращаемся ко всем объектам внунтри любого объекта с классом контент. 
  И теперь и p и span перекрасились
  */
  /* Если просто обратиться к .content но без *? - Есть css-параметры кот.
  наследуются и есть которые нет. В частности color наследуется и весь 
  текст внутри любого объекта с классом .content он перекрасится но это только потому что
  цвет наследуется, по этому нам нужно четко понимать к чему мы обращаемся */
}

/* Обращаемся к нескольким объектам */

.content p,
.content span {
  /* Обратились ко всем тегам P но только к тем
	которые находятся внутри любых объектов с классом .content на странице.
	И ко всем тегам SPAN но только к тем 
	которые находятся внутри любых объектов с классом .content на странице.*/
  /* color: red; */
}

.content .content__item,
.content .content__text {
  /* Обратились ко всем объектам с классом content__item но только к тем
	которые находятся внутри любых объектов с классом .content на странице.
	И ко всем объектам с классом content__text но только к тем 
	которые находятся внутри любых объектов с классом .content на странице.*/
  /* color: red; */
}

/* Так же мы можем не использовать вложеность
(это все зависит от того как кому именно мы хотим обратиться)
Но приоритет будет меньше чем выше, так как есть вложенность. */
.content__item,
.content__text,
footer {
  /* color: yellowgreen; */
}

/* Только первый уровень вложенности */
/* Это все редко используется */
.content span {
  /* Обратились ко всем тегам SPAN но только к тем
	которые находятся внутри любых объектов с классом .content на странице. 
	Мы постучались в .content и обратились ко всем span 
	но внутри объекта с классом .content. И соответственно у нас перекрасились 2 span  */

  /* color: red; */
}

/* Но у нас задача обратиться к первому уровню вложености и в этом
на поможет > */
.content > span {
  /* Обратились ко всем тегам SPAN ПЕРВОГО УРОВНЯ но только к тем 
	которые находятся внутри любых объектов с классом .content на странице. */

  /* color: red; */
}
/* Что бы обратиться к span второго уровня правильная конструкция будет  */
.content .content__text > span {
  /* color: blueviolet; */
}

/* Обращаемся только к первому следующему объекту того же уровня */

.content__item + * {
  /* color: yellowgreen; */
  /* .content__item  это наш p к которому мы обратились,
  а span с классом .content__text это следующий в html дереве 
  которому мы передали color: yellowgreen;
  (.content__item и .content__text находятся на одном уровне)  */
}
.content__item + div {
  /* color: yellowgreen; */
  /* То только следующий div после объекта с .content__item будет подсвечиваться */
}

/* Обращаемся ко всем следующим объектам того же уровня */

.content__item ~ span {
  /* вместо селектора тега тут может быть селектор класса, звездочки и т.д.  */
  /* color: yellowgreen; */
}

/* Чаще будет использовать это */
/* Мы будет так обращаться без вложенности, 
без дополнительных приоритетов, просто у нас будет каскадом 
идти вниз, и приоритетность соответственно будет легко читаться,
потому что у нас будут равнозначные селекторы классов. В редких случаях мы будем 
делать что-то подобное .content__text p{},.content__text *{} и т.д. */
.content {
}
.content__item {
}
.content__text {
}
