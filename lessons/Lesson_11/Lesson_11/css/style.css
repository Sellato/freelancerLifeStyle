/* УРОК №11 
https://youtu.be/TO9dU609mxE  
*/
/* Шпаргалка 
https://fls.guru/cssposition.html 
*/
/* 
&display=swap
&subset=cyrillic-ext 
*/

/* ОБНУЛЕНИЕ СТИЛЕЙ */
*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
	box-sizing: border-box;
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html,
body {
	height: 100%;
}
html {
	font-size: 16px; /* по умолчанию */
}
body {
	line-height: 1;
	/* color: #000; */
	/* font-family:""; */
	overflow-x: hidden;
	font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
}
.wrapper {
	padding: 50px;
	min-height: 100%;
}
/* ------------------------------ */
/* Позиционирование 

position: static; 

Позиционирование расширяет глобально наши возможности по расположению позицинированию объектов на странице.
Обратная сторона позицинирования это очень низкая надежность при изменении контента этот объект не будет влиять на другие объекты и мы получим что то ужасное. */

.block {
	padding: 100px 0;
	/* По умолчанию */
	/* position: static;  этот параментр написан для каждого объекта, просто мы его не пишем не видем, потому что он по умолчанию. При position: static;  объект статичен и мы не можем ничего с ним делать в том числе использовать дополнительное позиционирование а именно 	top left right bottom и z-index.
	 position: static;  может понадобиться только в том слечае если мы изначально указали некое другое значение, потом допустим при адаптиве или при каком то скрипте js  решили отменить значение, тогда мы можем вернуть его на static, во всех остальных случаях писать его не нужно.*/
	/*
	top
	left 
	right
	bottom
	z-index
	*/
}

/* Статичное положение объекта (по умолчанию) */
/* top,left,right,bottom,z-index - не работают */
/* position: static; */

/* -------------------------------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------------- */
/* 
position: relative; 
*/
/*
Положение элемента устанавливается относительно 
его исходного положения в коде. 

position: relative; это относительное позицинирование, относительно изначального положения. По этому после того как мы указали position: relative; у нас собственно ничего не изменилось, 
но мы переключили тип позицинирования и теперь мы можем использовать свойства top left right bottom и z-index. 

С position: relative; можно работать задавая его и объекту который мы и не позицинируем, но объекту относительно чего мы хотим позицинировать, это такая особенность этого параметра.

Добавление свойств left, top, right и bottom изменяет 
позицию элемента и сдвигает его в ту или иную сторону 
от первоначального расположения.
*/
/* top,left,right,bottom,z-index - работают */
/* position: relative; */

/* ------------------------- */
/* position меняет тип позицинирование объекта, чем то похоже на display. position это тоже себе такой переключатель позицинирования у объекта, не посредственно к которому позицинируем. А так же он влияет на родительский объект. 
В отличии от display position работает одинаково ко всем объектам - будь то строчный, будь то блочный объект.*/
.block__item {
	/* общие стили для элемента */
	padding: 15px;
	color: #fff;
	font-size: 20px;
	/* position: relative; */
	margin: -20px 0px 0px 0px;
}
/* конкретные стили по модификатом */
.block__item_color-brown {
	background-color: #794f45;
	z-index: 2;
	position: relative; /* сдвигается относительно начального положения, мы какими то другими средствами установили объект, и потом добавили position: relative; и с помощью 	top left right bottom мы его сдвигаем относительно этого положения. */
}
.block__item_color-purple {
	background-color: #77608d;
	/* но поскольку тут не будет 	position: relative;, то включится работа потомков .block__item_color-purple span и потомок с вышим индексом будет выше чем  .block__item_color-brown */
	/* z-index: -1;  он будет ниже всего, но это не совсем работает  в браузере сафари, по этому не рекомендуют это использовать.*/
}
.block__item_color-purple span {
	display: inline-block;
	padding: 10px;
	color: black;
	background-color: yellow;
	position: relative; /* объект стал позицинироваться относительно своего положения, включились дополнительные свойства позицинирования сторон, мы с помощью этих свойств можем сдвигать объект относительно своего места положения. */
	left: 100px;
	/* left: 30%; при процентном значении будет браться процент от ширины родителя, то есть чем шире родитель тем на большие пиксели будет сдвинут объект. */
	/* top: -10px; здесь будет зависить от высоты родителя. Сдвинутый объект никак не влияет на окружение, мы можем его двигать куда угодно - вверх-вниз 
относительно верха, относительно лева.*/
	top: 30px; /* Фактически мы указваем на сколько пикселей нам отступить, с той или иной стороны, на пример сверху на 30 пикселей, или -30px отрицательно вверх и тоже самое снизу. Так же слева и справа. */
	/* top: 50%; проценты не будут работать для вертикальных свойств при	position: relative;   Будет работать с указанием высоты height. */
	/* Процентные значения для вертикали работают если у нас высота объекта больше чем сам объект вместе с отступами, процентное значение зависит от высоты - 50% от 100px или 200px, нужно место куда сдвигаться. */

	z-index: 3;
	/* z-index: -1;  он будет ниже всего, но это не совсем работает  в браузере сафари, по этому не рекомендуют это использовать.*/
}
.block__item_color-green {
	background-color: #7a956b;
	z-index: 1;
	position: relative; /* не наследуется. */
}
/* Если у всех трех блоков z-index одинаковый тогда срабатывает иерархия в html - чем ниже объект тем он будет главнее.  

z-index: auto; - говорит что он автоматический и включается порядок следования в html.
z-index: 0; - это конктретному указваем что ты z-index: 0; и порядок в html уже учитываться не будет.
*/

.block__item_color-purple {
	/* если нам нужно подтянуть отрицательным margin и убрать артифакт что текст у нас виден, 
	мы просто добавляем 	position: relative; если нужно то еще 	z-index для того что бы этот объект был выше. */
	position: relative;
	margin: -30px 0px 0px 0px;
	background-color: #77608d;
}
/* position: relative; со сдвигом не влияет на БЭМ блоки, 
потому что вне зависимости куда бы мы не поставили такой блок он будет везде вести себя одинаково и никак не влиять на окружение. */

/* ------------------------------------------ */
/* Пример */
/* 1) Если задать отрицитальный margin */
.block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
}
.block__item_color-brown {
	background-color: #794f45;
}
.block__item_color-purple {
	background-color: #77608d;
	/* Тут происходят 3 вещи: пурпурный блок наваливается на коричневый, но текст коричневого все равно светлый, а третий блок зеленый подтягивается вместе с пурпурным вверх */
	margin: -30px 0px 0px 0px;
}
.block__item_color-green {
	background-color: #7a956b;
}
/* 2) Если задать отрицитальный 	position: relative; */
.block__item {
	padding: 15px;
	color: #fff;
	font-size: 20px;
}
.block__item_color-brown {
	background-color: #794f45;
}
.block__item_color-purple {
	background-color: #77608d;
	/* Тут происходят 3 вещи: объект пурпурный налез на коричневый, текст коричневого скрыт(текст пурпурного выше, потому что	position: relative;,
	  у коричневого ничего нет, по этому пурпурный выше в z-index), а зеленый блок никуда не сдвинулся, потому что объект сдигается относительно своего место положения никак не влияя на окружение - не на те объекты на которые он залез, не те объекты которые следуют за ним. То есть сдвиг происходит как бы клона - 
	  один остается на занятом его местом, а видимая часть двигается. */
	position: relative;
	top: -30px;
}
.block__item_color-green {
	background-color: #7a956b;
}
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/*
 position: absolute; 
  */
/*

Когда для объекта задается position: relative; которое мы хотим позицинировать, то этот объект позицинируется относительно своего изначального места положения,
а position: absolute; позицинируется относительно первого родителя у которого задан position: relative; Также второе действие которое происходит, когда мы переключаем тумблер 
в position: absolute; объект становится условно строчным, потому что он теряет свою ширину постоянную, даже если это блочный объект и он становится по ширине и высоте 
по контенту, сколько в нем контента то такого он и размера.

Элемент якобы вырывается из кода и зависайт в воздухе(то есть он теряет своё место, и его место занимают другие объекты). 
Он перестает влиять на остальные элементы. 
Добавление свойств left, top, right и bottom 
изменяет позицию элемента и сдвигает его 
в ту или иную сторону относительно родителя 
у которого задан параметр position: relative;

Происходят 3 вещи:
1) Объект теряет свое "тело", и зависает в воздухе.
2) Другие объекты занимают его место
3) Объект превращается в строчный, тоесть 
размер зависит от контента в нем
4) Объект позиционируется обносительно первого родителя,
для которого указано position: relative;
5) Необходимо сопровождать свойствами top,left,right,bottom

*/
/* top,left,right,bottom,z-index - работают */
/* position: absolute; */

.block-2 {
	position: relative;
}
.block__item-2 {
	padding: 15px;
	color: #fff;
	font-size: 20px;
}

.block__item_color-brown-2 {
	background-color: #794f45;
}
.block__item_color-purple-2 {
	position: absolute;
	top: 0;
	left: 0;
	background-color: #77608d;
	/* он начинает двигаться вверх и искать родителя для которого указан position: relative;
	он нашел первого родителя с классом .block-2, и справщивает у него - ты position: relative;? он отвечает - нет. 
	И побежал дальше к main с классом .main. Ты position: relative;? он отвечает - нет. И так дальше аж до body(родитель самого верхнего уровня).
	То есть он в итоге отпозицинировался относительно body в верхнем левом углу. Все это будет происходить относительно body, потому что объект не нашел 
	другого родителя, у которого задан position: relative; Но если мы укажем .block-2 position: relative; то .block__item_color-purple-2  будет позицинировать относительно .block-2.
	И теперь мы можем перещать объект относительно родителю с position: relative;

	Важно!!!
	Минус	position: absolute; в том что мы не можем никак контролировать изменение контента, 
	точнее при изменении контента больше ничего происходить не будет. И контент увеличивается, но он не влияет на окружение, по этому это может вызвать вот такую ситуацию.
	По этому не нужно позицинировать объекты которые влияют на окружение с помощью абсолютного позицинирования. Абсолютное позицинирование на то и абсолютное позицинирование что мы взяли объект, поместили
	и там он теперь и находится и это не подразумевает изменение в нем контента. Если мы говорит об изменении контента при другом позицинировании либо отсутствие позицинирования
	это влияет на окружение и так или иначе блоки раздвигаются/сдвигаются и как то взаимодействуют между собой. 
	При абсолютном позицинировании оно абсолютно и там никакая логика не работает.

	Абсолютное позицинирование может быть использовано 

	*/
}
.block__item_color-green-2 {
	background-color: #7a956b;
}
/* -------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* 
position: fixed; 
*/
/*
position: fixed; очень схож с position: absolute; но у него есть 2 отличия: Объект позиционируется обтосительно окна браузера, он всегда будет позицинироваться окна браузера, не смотря на то что его папа position: relative;.


Элемент якобы вырывается из кода и зависайт в воздухе. 
Фиксируется, то есть не скролится вместе с содержимым. 
Он перестает влиять на остальные элементы. 
Добавление свойств left, top, right и bottom изменяет позицию элемента 
и сдвигает его в ту или иную сторону относительно окна браузера.
*/

/*
1) Объект теряет свое "тело", и зависает в воздухе.
2) Другие объекты занимают его место
3) Объект превращается в строчный, тоесть 
размер зависит от контента в нем
4) Объект позиционируется обносительно окна браузера(окно браузера это то что мы видим, именно видимая часть viewport),
 это приведет к том что объект не булет скролиться вместе с другим контентом, потому что окно браузера статично, скролится контент в нем - body скролится, но фиксированые объекты position: fixed; не будет скролиться вместе с контентом.
5) Необходимо сопровождать свойствами top,left,right,bottom

*/

/* top,left,right,bottom,z-index - работают */
/* position: fixed; */

/* -------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/*
position: sticky; 

Это гибридное сочетание значений static и fixed. 
Изначально элемент ведет себя как static 
но после того как скролл доходит до его границы он становиться 
fixed и прилипает к указанной позиции top или bottom.
*/

/* С overflow: hidden; не рабоатет.
То есть объект теперь будет прилипать к верху и отлипать когда мы доходим до низа блока. 

Если контент не влазит в экран, он все равно прилипает, соответственно у нас нет шансов добраться до низа пока мы не упремся блоком в конец и это не подходит для плавающих блоков. Мы не можем использовать стики 
без js так как сам sticky не умеет определить помещается он в экран или нет.*/

/* top,left,right,bottom,z-index - работают */
/* position: sticky; */

/* -------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/*
z-index

Каждый элемент может находиться как ниже, 
так и выше других объектов веб-страницы, 
их размещением по z-оси и управляет z-index. 
Это свойство работает только для элементов, 
у которых значение position отличное от static.
*/

/* 
z-index: auto; - говорит что он автоматический и включается порядок следования в html.
z-index: 0; - это конктретному указваем что ты z-index: 0; и порядок в html уже учитываться не будет.
z-index: -1;  он будет ниже всего, но это не совсем работает  в браузере сафари, по этому не рекомендуют это использовать.
*/

/* -------------- */
/*
 Свойства позиционирования,
можно указавать px, %, другие ед.
top
left
right
bottom
*/
/* Абсолютное позицинирование и фиксированое влияет на окружение то соответственно мы не можем задавать position: absolute; и position: fixed; для БЭМ блока, мы можем задавать position: relative;   */

/* -------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* ---------------------------------------------------------------------------------------------------------------- */
/* Практика */

/* ----------------------- пример 1 ------------------------- */
/* Это декор, это все меняться не будет и мы спокойно применять позицинирование */
.list {
}
.list__item {
	position: relative;
	/* Важно!!!!!!!! */
	padding: 0px 0px 0px 25px; /* padding - это внутренний отступ, а объекты позицинируются относительно самого объекта, то есть padding не влияет на позицинирование. Но если тут будет margin то объект сдвинется 
	вместе с абсолютным объектом, то есть margin внешний отступ и мы всю комнату сдвигаем, а внутри комнаты у нас есть позицинирование. 
	Внутренний отступ сдвигает контент но абсолютно позицинированый объект будет позицинироваться все равно в рамках объекта, а внешний оступ будет сдвигать  позицинированые объекты относительно 
	объекта для которого задается внешний отступ.*/
}
.list__item::before {
	content: "";
	background: url("../img/icon.png") 0 0 no-repeat;
	width: 25px;
	height: 25px;
	position: absolute;
	top: -6px;
	left: 0px;
	transition: all 0.3s ease 0s;
}
.list__item:hover::before {
	transform: scale(1.5);
}
.list__item:not(:last-child) {
	margin: 0px 0px 10px 0px;
}
/* ----------------------- пример 2 ------------------------- */
/* шапка */
.header {
	background-color: #7a956b;
	padding: 20px;
	position: fixed;
	width: 100%;
	top: 0;
	left: 0;
	z-index: 100; /* для того что бы этот объект был выше всех остальных объектов. */
}
/* из за того что объект теряет свое тело, мы видим что контент залез под объект, по этому в таких случаях нам дополнительно необходимо устанавливать padding-top для .main 30px */
.main {
	padding: 30px 0px 0px 0px;
}
/* ----------------------- пример 3 ------------------------- */
/* безопасное использование position */
.image {
	position: relative;
	display: inline-block;
}
.image::before {
	content: "";
	position: absolute;
	width: 100%;
	height: 100%;
	top: 0;
	left: 0;
	background-color: rgba(0, 0, 0, 0.5);
}
.image:hover::before {
	opacity: 0;
}
.image__item {
	width: 200px;
}
/* ----------------------- ------------ ------------------------- */
/* ----------------------- пример 4 ------------------------- */
.test {
	background: #f5f5f5; /* цвет фона следует должен быть  на главном блоке, это полотно и должно быть на любую ширину экрана */
	padding: 110px 30px;
	position: relative;
	background: url("../img/blob.png") right -489px no-repeat;
}
