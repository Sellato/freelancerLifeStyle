/* №14 
https://youtu.be/xG7aKfABjFo  
*/
/* 
&display=swap
&subset=cyrillic-ext 
*/

/* ОБНУЛЕНИЕ СТИЛЕЙ */
*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
	box-sizing: border-box;
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html,
body {
	height: 100%;
}
html {
	font-size: 16px; /* по умолчанию */
}
body {
	line-height: 1;
	/* color: #000; */
	/* font-family:""; */
	overflow-x: hidden;
	font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
	background-color: #333;
}
.wrapper {
	min-height: 100%;
	padding: 30px;
	overflow: hidden;
}
/* ------------------------------ */

.main {
	background-color: rgba(255, 255, 255, 0.05);
	/* height: 500px; */
}
/*
Flexbox - это целый модуль, содержащий в себе набор свойств и их значений как для родителя flex-контейнера так и для его дочерних элементов flex-элементов. 
Основным преимуществом гибкой FLEX разметки является возможность изменять ширину/высоту пространство вокруг и 
порядок flex-элементов, для того чтобы наилучшим образом заполнить доступное пространство flex-контейнера. 
*/

.main__block {
	margin: 0 -10px;
	padding: 50px 0;
}
/* Флекс-контейнер */
.block {
	/* height: 600px; */

	/* Включение флекс-модуля */
	display: flex; /* и сразу объекты внутри родителя выстроились в ряд по оси x - эта основная ось. Они выстраиваются слева-на право. Флекс элементы фактически становятся якобы блочно-строчными(их ширина зависит от контента, который находится в нем) . */
	/* Когда мы задаем родителю 	display: flex; - мы делаем его блочным и он будет занимать всю ширину родителя. */

	/* display: inline-flex; в этот момент с флекс элементами происходит все тоже самое что и для обычного 	display: flex; , но сам контейнер становится блочно-строчным.(мы увидим фантомный отступ) */
	/* На display: inline-flex; будут действовать фантомные отступы. Мы можем задать text-align:center; для родителя и все наши display: inline-flex выстроятся по центру. */

	/* Свойства флекс контейнера работают с простым пространством контейнера, если оно есть. Соответственно если у нас inline-flex - это значит что флекс контейнер будет занимать ширину по ширине контента в нем, то есть флекс элементов
соответственно у него не будет пустого пространства с которым можно работать. Когда display: flex; именно с этим пространством мы можем работать. */

	/* Когда объект не помещается внутрь флекс-контейнера - (в случае с блочно-строчными элементами такие элементы перескакивали бы на новую строку), 
	а здесь они никуда не перескакивают и здесь по другому идет выравнивание(нету фантомных отступов). 
	Абсолютно не важно какого типа были объекты до того как мы включили флекс-модуль. Никакой разницы- спан это или див. Когда объекты становятся флекс-элементами(не посредственно первый уровень вложенности)
   на них начинает действовать правило,что они становятся якобы блочно-строчными и выравнивание.  */

	/* Любой флекс-элемент может быть флекс-контейнером. Если задать флекс-элементам display: flex;   justify-content: center; align-items: center; то соответственно все что внутри ячеек выровнялось по центру по горизонтали и вертикали. */
	/* ------------------------------------------------------ */
	/* Определяет смогут ли flex-элементы перемещаться на следующие строки когда перестают помещаться внутри flex-контейнера. 
	Оно отвечает за то как будут себя вести элементы, когда они не помещаются в флекс контейнер. */
	/* flex-wrap: nowrap; по умолчанию. Это значит что между нашими флекс элементами, когда мы включаем display: flex;/display: inline-flex;, будет скреплено намертво, то есть такие объекты не сломаются. */
	/* flex-wrap: wrap; когда элементы не помещаются в свой флекс контейнер, они будут перескакивать на следующую строку один под другой.*/

	/* ---------------------------------------------------------------------- */
	/*  
	Определяет выравнивание вдоль основной оси(слева на право) (направление зависит от значения свойства flex-direction). 
	Влияет на пустое пространство (display: flex;).
	*/
	/* justify-content: flex-start; по умолчанию. Они прижаты к началу, к левому краю. Но это зависит от направления flex-direction)*/
	/* justify-content: flex-end; справа*/
	/* justify-content: center;*/
	/* justify-content: space-between; раскидывает объекты что бы между ними было одинаковое пространство.  */
	/* justify-content: around; берется все пространство и делится так что он ставит куски пространства  слева и справа от объекта.*/
	/* justify-content: evenly; пространство распределяется поровну между объектами*/

	/*
	------------------------------------------------------------------------- 	
	Определяет выравнивание вдоль поперечной оси(сверху вниз) (направление зависит от значения свойства flex-direction). 
	*/
	/* align-items: stretch; (резиновый) по умолчанию. Чем выше будет объект тем выше будут и все другие объекты по умолчанию.*/
	/* Они очень похожи на значения justify-content */
	/* align-items: flex-start; сверху по второстепенной оси. justify-content  по основной оси, align-items по второстепенной. */
	/* align-items: flex-start;
	    align-items: center; 
      align-items: baseline; выравнивает объекты по линии шрифта. */
	/*

		---------------------------------------------------------------------- 	
	Устанавливает основную ось, таким образом определяет направление flex-элементов расположенных в flex-контейнере.
	*/
	/* flex-direction: row; по умолчанию. Объекты выстраиваются в ряд.*/
	/* flex-direction: row-reverse;  Это тоже ряд, но все на оборот. Разворот объектов и теперь все начинается справа на лево. 
	При чем это объекты не прижаты к праву как было с justify-content: flex-end; Объекты прижаты к праву но их порядок все равно слева на право. То есть мы разварачиваем полностью все и у нас теперь будет начинаться справа. 
Когда у нас указано flex-direction: row-reverse;  наша линия меняет направление, она уже начинается справа и стремиться влево. 
Мы ее развернули и теперь разварачиваются соответсвенно все значения justify-content - justify-content: flex-end;  будет теперь слева.*/

	/* flex-direction: column; поменяли основную и второстепенную ось. Теперь основная ось у нас стала y, а второстепенная x. Теперь мы выстраиваем наши флексы элементы не слева на право или справа на лево в ряд, а  
мы теперь выстраиваем сверху вниз и это есть основная ось - сверху вниз. А слева на право это у нас уже второстепенная ось. В такой конфигурации align-items: stretch;  объеты заполняют всю ширину экрана, но это только потому что 
 align-items по умолчанию stretch. Если мы изменим это на align-items: flex-start;  то у нас объекты прижмутся к левому краю.
  flex-direction: column-reverse; теперь все на оборот - снизу вверх.*/

	/*
			--------------------------------------------------------------------- 	
	Определяет выравнивание вдоль поперечной оси, при наличии свободного пространства, и флекс-элементы расположены в 2 и более строки (направление зависит от значения свойства flex-direction). 
	*/
	/* В момент когда у нас есть пустое пространство по не основной оси - объекты которые в 2 строки выстраиваются при использовании align-items, объекты которые перескочили на другую строку, по умолчанию будет распределено 
	пространство между ними(между верхним и следующим нижним рядом). За это пространство отвечает align-content. Соответственно спомощью align-content: flex-start; мы можем эти объекты прижать к верху. 
	При этом нам уже  align-items: flex-start; и не нужен, в таком случае объекты будут стречиться. */
	/* align-content: stretch; по умолчанию объекты будут растягиваться по всей высоте их флекс контейнера*/
	/* align-content: flex-start; */
	/* align-content:  flex-end; */
	/* align-content: center; */
	/* align-content: space-around; */
	/* align-content: space-between; */
	/* align-content: space-evenly; */
	/* То есть когда у нас обычный flex-direction, когда у нас по той или иной причине высота флекс контейнера больше чем совокупность высот флекс элементов то есть у нас есть свободное пространство, 
 с помошью align-content мы можем этим пространством управлять, но видно это когда у нас больше одной строки флекс элементов, то есть мы по любому задействуем flex-wrap: wrap;  
 И когда у нас есть несколько строк и при этом есть свободное пространство только тогда align-content мы можем использовать. */
	/* --------------------------------------------------------------------- */
	/*
	Управляет расстоянием (отступами) (разрывом) между флекс-элементами
	Это отступы которые работают внутри модуля флекс.
	*/
	/* 
	Объекты отступают только между друг другом, а там где они примыкают к флекс контейнеру- отступов нет.

	row-gap - между рядами
	column-gap - между колонками
	gap: row-gap column-gap;  отступ вниз, отступ справа.
	 */
	/* gap: 20px; */
	row-gap: 20px;
}
/* Соответственно если по вертикали нам не куда отступать, то есть нет объектов для разрыва/растояния, то  row-gap: 20px; мы не увидим. */
/* --------------------------------------------------------------------- */
/* Свойство order */
/* Флекс-элемент */
.block__element {
	margin: 0 10px;
	background-color: #77608d;
	padding: 20px;
	font-size: 30px;
	color: #fff;
	flex: 0 0 100%;
}

/*
Управляет порядком, в котором располагаются flex-элементы внутри flex-контейнера.
*/

.block__element:nth-child(1) {
	order: 0;
}
.block__element:nth-child(2) {
	order: 1;
}
.block__element:nth-child(3) {
	order: 2;
}
.block__element:nth-child(4) {
	order: 3;
}

.block__element_first {
	/* -------------------------------------------------------------------------------------------------------- */
	/*
	Переопределяет для конкретного flex-элемента выравнивание вдоль поперечной оси (направление зависит от значения свойства flex-direction).
	*/
	/* align-self: auto; по умолчанию */
	/* align-self: center; довольно часто используется. */
	/* align-self: flex-start; и только этот объект будет прижат к верху, к которому мы написали это свойство align-self  */
	/* -------------------------------------------------------------------------------------------------------- */
	/* -------------------------------------------------------------------------------------------------------- */
	/* Управление размером флекс элементов */
	/*
	Определяет размер элемента по умолчанию, до распределения оставшегося пространства. Значения могут быть в процентах пикселях и т.д.
	То есть это некий базовый размер объекта который мы изначально устанавливаем (не путать с width, потому что flex-basis определяет некий желаемый размер объекта, если есть место в флекс контейнере). 
	*/
	/* flex-basis: auto; по умолчанию зависит от размера контента. Если мы работаем flex-direction: row; либо flex-direction: row-reverse; то  flex-basis будет отвечать за ширину. */
	/* flex-basis: 200px; то есть он стал 200px по ширине. Если убрать flex-wrap: wrap; то как только объектам не хватает места, наш 200px объект начинает сужаться. То есть flex-basis это не есть равно width*/
	/* Не стоит использовать значение за которое отвечает flex-basis. То есть если мы говорим за flex-direction: row; по умолчанию либо flex-direction: row-reverse; то мы управляем flex-basis якобы шириной, 
	а высотой управляем height. Если мы разварачиваем flex-direction:column; то высотой мы управляем flex-basis: а шириной width. То есть мы использовать свойства ширины либо высоты для управления не основной линии но 
	основная линия лучше использовать flex-basis. */
	/* flex-basis: 50%; */
	/* flex-basis: 100%; объект будет стремиться занять все доступное пространство.  То есть это что то схожое если у нас flex-grow: 1; и  flex-basis: auto; или любой flex-basis. И если мы поставим ему flex-shrink: 0; то он вытеснет другие объекты, то есть мы запретим ему уменьшаться, он будет точно занимать все пространство. */
	/* -------------------------------------------------------------------------------------------------------- */
	/*
	Определяет возможность элемента увеличиваться в размере, при необходимости заполняя весь flex-контейнер. 0 запрещено. 1 разрешено. 
	Оперделяет может ли объект увеличиваться шире чем flex-basis.
	*/
	/* flex-grow: 0; по умолчанию объектам запрещено увеличиваться, именно по этому они как бы в стандартной конфигурации flex-direction прижимаются к левому краю 
	и становятся как бы блокчно-строчными, то есть зависят от ширины контента, потому что по умолчанию flex-basis: auto; а flex-grow: 0; Но стоит нам поменять flex-grow: 1;   для всех объектов - они все будут
	увеличиваться, мы разрешаем им увеличиваться и они будут стараться пропорционально завладеть всем пустым пространством.
	Если мы зададим flex-grow: 1;  для одного объекта, он начнет увеличиваться, пытаться заполнить все пустое пространство. Все остальные объекты для которых flex-grow: 0; Они остануться в пределах ширины своего контента так как 
	это было изначально.*/
	/* -------------------------------------------------------------------------------------------------------- */
	/*
	Определяет возможность элемента уменьшаться в размере, при необходимости заполняя весь flex-контейер. 0 запрещено. 1 разрешено.
	Оперделяет может ли объект уменьшаться относительно flex-basis.
	*/
	/* flex-shrink: 1; по умолчанию*/

	/*
	Определяет возможность элемента уменьшаться и увеличиваться в размере, при необходимости заполняя весь flex-контейнер (0 запрещено. 1 разрешено). А так же задаёт базовый размер. 
	*/
	flex-basis: 200px; /* объект станет 200px по ширину */
	flex-grow: 1; /* если задать, то объект может стать больше если есть пустое пространство(это что то схожое с min-width - то есть когда мы задает объекту ширину но минимальную, то есть объект больше может становиться, а меньше нет, но может сейчас становится и больше и меньше) */
	flex-shrink: 1; /* а меньше 200px он может становится потому что flex-shrink по умолчанию = 1; то есть объекту разрешено уменьшаться меньше его flex-basis */
	flex-shrink: 0; /* если мы поменяем на 0 то у нас получится класический min-width. То есть все флекс будут работать как min-width: 200px;(а при min-width: 200px; для блочного объекта он будет на всю ширину родителя на сколько это возможно, но меньше не станет.*/
	/* Соответственно если  поотключаем flex-grow: 0; flex-shrink: 0;  установим flex-basis: 200px; фактически это как для обычного объекта мы указали конкретно width: 200px; Мы запретили увеличиваться и запретили уменьшаться.
	Не советуют по основной оси работать с widthи height а работать с flex-basis flex-grow и flex-shrink.*/
	/* Универсальное свойство */
	flex: 0 1 auto;
	flex: 0 1 200px; /* разрешено уменьшаться */
	flex: 0 0 200px; /* запрещено уменьшаться */
	flex: 1 0 200px; /* разрешено увеличиваться */
	flex: 0 0 200px; /* запрещено увеличиваться */
	flex: 0 0 33.333%; /* будет всегда треть от всей ширины флекс контейнера. Трех-колоночная система*/
	flex: 0 0 50%; /*  Двух-колоночная система*/
}
/* Ширина флекс-элемента который находится на 2-ой строке не будет зависить от ширины флекс-элемента  на 1-ой строке. В этом кардинальное отличие флекса от гридов, потому что в гридах есть зависимость.
То есть при уменьшении ширины нельзя сделать так что бы ширина второй ячейки на 1-ой строке влияла на ширину ячейки 4 2-ой строке. Они между собой не связаны, как в гридах.*/
/* -------------------------------------------------------------------------------------------------------- */
/* Пример */
/* Плохой вариант сделать оступы gap */
/* .box {
	max-width: 1290px;
	display: flex;
	flex-wrap: wrap;
	gap: 20px;
	border: 10px solid rgb(169, 22, 22);
	margin-bottom: 20px;
}
.box__element {
	border: 10px solid rgb(133, 128, 128);
	padding: 20px;
	font-size: 30px;
	color: #fff;
	flex: 0 0 32.28346456692913%;
} */
/* -------------------------------------------------------------------------------------------------------- */
/* 1270 - 40 = 1230 / 3 = 410
410 / 1270 * 100% = 32,28346456692913%

800 - 40 = 760 / 3 = 253,3333333333333
253,3333333333333 / 800 * 100% = 31,66666666666666% */
/* -------------------------------------------------------------------------------------------------------- */
/* Пример 2*/
/*  */
.box {
	margin: 0 -10px;
	font-size: 0;
	display: flex;
	flex-wrap: wrap;
	row-gap: 20px;
}
.box__element {
	padding: 0 10px;
	font-size: 30px;
	color: #fff;
	flex: 0 0 33.333%;
}
.box__content {
	background-color: #77608d;
	padding: 20px;
	height: 100%; /* что бы контентный объект был по всей высоте */
}
