/* &display=swap&subset=cyrillic-ext */

/* ОБНУЛЕНИЕ СТИЛЕЙ */
*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
	box-sizing: border-box; /* И теперь наши ширины будут включать в себя отступы внутренние, границы и не включать в себя внешние отступы. */
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html,
body {
	height: 100%;
}
html {
	font-size: 16px; /* по умолчанию */
}
body {
	line-height: 1;
}
.wrapper {
	/* весь контент мы помещаем сюда. Он как раз служит предохранителем для отрицательных margin и не только. Мы излечим наш сайт от возможных проблем горизонтального скрола */
	min-height: 100%; /*  что бы wrapper у нас занимал всю высоту экрана всегда. Это нужно будет потом для позицинирования footer и т.д. */
	overflow: hidden; /* наш горизонтальный скрол исчез. 
	Мы не можем задать overflow: hidden;  для body, потому что  что бы остался вертикальный скрол. Если мы зададим overflow: hidden;  для body - у нас пропадет вертикальный скрол и мы не добраться 
	до объектов кот. ниже, потому что  overflow: hidden; скрывает все что выходит за пределы блока.*/
}
/* ------------------------------ */
/* Отступы */
/* По другому работают для строчного объекта*/

/* Внутренние */
/*Внутренние отступы отталкивают контент находящийся внутри объекта как бы во внутрь, в зависимости от того с какой 
стороны мы делаем отступ или сразу со всех 4-х сторон, контент внутри объекта будет
сжиматься, отталкиваться от границ(условных границ, они могут быть не видны, но фактически это прямоугольник).
И нам нужно понять что нужно сделать:а) Оттолкнуть объект от окружения; б)или оттолкнуть контент внутри него 
от его границ. И таким образом принимается решение какой из отступов выбрать.

padding
Внутренний отступ элемента
При указании поля в процентах, значение считается 
от ширины родителя элемента.
Свойство не наследуется.

padding: со_всех_сторон;
padding: сверху справа снизу слева;
padding: сверху_снизу справа_слева;
padding: сверху справа_слева снизу;

snippet ppp - это padding: 0px px; когда нам нужно 
поставить одинаковые отступы слева-справа.

Внутренний отступ чаще всего используется когда у нас есть объект 
и нам нужно действительно оттолкнуть контент от его границ.

Процентный отступ.
padding: 20% 0px 0px 0px; если мы поставим сверху 20% то эти 20% возьмутся 
от ширины объекта. В данном случае у нас какая-то ширина объекта, 
от нее возьмется 20% и будет такой же отступ (чем уже будет объект тем меньше будет оступ, 
чем больше будет объект тем больше будет отступ).
*/

/* Внешние */
/*Это отступ всего объекта от внешних объектов, кот. его окружают.
Внещние отступы либо отталкивают сам объект от окружающих его объектов, либо оттаклкивают окружающие объекты от самого объекта, 
в зависимости от того, какой мы даем отступ. Соответственно если мы зададим отступ вверх внещний,то сам объект оттолкнентся от вверхнего объекта, 
а если мы зададим внешний отступ от объекта  вниз, то он оттолкнет нижний объект вниз. Если влево то сам объект оттолкнется, если вправо то он отттолкнет
другие объекты и сам останется на месте.

margin
Внешний отступ элемента
При указании поля в процентах, значение считается от ширины родителя элемента.
Свойство не наследуется.
Значение может быть как положительным, так и отрицательным числом(и это его огромный плюс). Допустим
мы хотим что бы наш нижний блок как бы навалился на верхний, для этого мы используем margin: -50px 0px 0px 0px;
Его супер способность в том что он будет тянуть за собой все что снизу, то есть мы не увидим разрыва между ними(с нижнем).
С отрицательным margin начал наезжать на верхний блок и тянуть за собой все что снизу. Отрицательный margin довольно
часто используется благодаря этой своей возможности тянуть за собой контент.

Обычно отступают вниз и вправо(мы читаем макет сверху вниз, слева на право), соответственно тому
блоку кот. выше по коду мы даем отступы. 

Схлопывание
Схлопывание можно избежать если следовать правилам что внешний отступ мы задаем вниз объектов и в право.
Если мы задали зеленому блоку margin: 0px 0px 50px 0px; а нижнему блоку задали margin: 100px 0px 0px 0px; и получится 
(если по логике то отступ в суме будет равен 150px) но на самом деле нет, отступ между ними будет равен 100px, потому что когда у нас есть несколько внешних
отступов -  они схлопываются и побеждает тот кот. больше. Соответственно 100px > 50px и в итоге у нас отступ будет равен 100px, не в 150px и не в 50px. 


margin: со_всех_сторон;
margin: сверху справа снизу слева;
margin: сверху_снизу справа_слева;
margin: сверху справа_слева снизу;
*/

.block {
	background-color: green;

	color: #fff;
	font-size: 30px;
	margin: 50px;
	padding: 30px;
}
.inline {
	background-color: #794f45;
	color: #fff;
	font-size: 30px;
	width: 500px;
	padding: 50px;
	margin: 50px;
}

.image {
	width: 50%;
	padding: 50px;
	background-color: #000;
}

.block_2 {
	background-color: #77608d;

	color: #fff;
	font-size: 50px;
	padding: 50px;
}
.block_3 {
	background-color: #794f45;
	padding: 50px;

	color: #fff;
	font-size: 50px;
	padding: 50px;
}

/* НЕ работают для строчного объекта*/
/*
width
Задает жесткую ширину объекта. (помним что любой блочный тег по умолчанию на всю ширину, фактически он по умолчанию 100% ширины родителя,
в какой бы  он родитель не был помещен, он будет стараться занять всю ширину, даже если там контента мало).
Устанавливает ширину блочных тегов и блочно-строчных
Свойство не наследуется, то есть к какому объекту мы его применяем только для этого объекта оно и будет работать.

Фиксированные ширины width:100px; мы практически нигде не будем использовать в своей работе, потому что это опасно - то есть указав какуе то фиксированную ширину
мы ограничиваем пользователя в открытии этого блока на разных устройствах. Фиксированные ширины это есть некое ограничение, некое связывание рук и ног для развития, 
для изменения контента, для интеграции верстки в другие устрайства уже и т.д.

width:10%;Ширина указанная в % соответственно процент высчитывается от ширины родителя. Соответственно теперь при box-sizing:border-box; если убрать внешние отступы 
то блок помещается , никакого горизонтального скрола нет даже при указании width:100%; даже и при width: auto; Теперь auto равно для него 100%, потому что внутренние отступы 
включены и границы, кроме внешних отступов. 

Указав width:50%; мы получим блок кот. занимает ровно половину от ширины родителя , если родитель шире то  соответственно эта поволовина тоже будет шире.
*/
/* Комбинация ширин и отступов. По умолчанию width: auto; у нас ширина установлена как auto - блочный тег будет занимать всю ширину родителя.
Но в данном контексте ширина 	width: 100%; она будет отличаться от ширины автоматической width: auto; потому что в тот момент когда мы задаем отличную от 
автоматической и у нас присутствуют внутренние отступы слева-справа то эти значения прибавляются, то есть мы берем 100% ширины родителя и прибовляем к нему
отступ слева-справа padding: 0 50px; тобишь еще +100px. Сейчас фактическая ширина блока это 100% ширины +100px именно по этому у нас появился горизонтальный скролл,
потому что мы указали фактическую ширину блока больше чем ширина родителя.  https://www.youtube.com/watch?v=DxgKWsDurdE  с 1:10:30.
По умолчанию когда мы указывает ту или иную ширину для блока - фактически мы указываем ширину для контента внутри блока( то есть контент кот. находится внутри
блока мы фактически для него указываем ширину(это 300px), но сам блок будет 400px на 100px больше как раз потому что к этой ширине прибавляется padding слева-справа по 50px.
По этому используют 	box-sizing: border-box; в обнулении.*/
.block {
	width: 500px;
}

/*
box-sizing
Применяется для изменения алгоритма расчета ширины 
и высоты элемента. 
Свойство наследуется.
content-box - Основывается на стандартах CSS, при этом 
свойства width и height задают ширину и высоту контента
 и не включают в себя значения отступов, полей и границ.
border-box - Свойства width и height включают в себя 
значения полей и границ, но не отступов (margin). Эта модель используется браузером Internet Exporer в режиме несовместимости.
padding-box - Свойства width и height включают в себя
 значения полей, но не отступов (margin) и границ (border). 

*/

/*
 Центрирование объекта с помощью  margin со значениями auto:last-child
 margin: 0px auto 0px auto; Блок наш выстроился по середине. Это один из методов центрирования контента, и для того что бы у вас это сработало, вам нужно 3 условия:	 
 1) Объект должен быть блочным
 2) Объект должен быть ограничен по ширине(почему? Потому что если мы не будем ограничивать блочный объект по ширине то он будет на всю ширину 
 родителя и центровать будет некуда), быть уже чем родитель
 3) На него нужно повлиять такой записью -  margin: 0px auto; - это сокращенная запись кот. гласит что сверху-снизу 0px, слева-справа auto, и тогда наш объект будет по середине.
*/

.block {
	margin: 0px auto;
	/* Лайфхак как прижать объект справа(слева он будет по умолчанию), это написать margin: 0 0 0 auto; То есть мы говорим объекту что слевой части у тебя автоматический отступ
	и он прижимается к правой части. Мы можем комбинировать эту запись margin: 50px 0 0 auto; margin: 50px 10px 50px auto;margin: 20px auto 50px; - но так где auto он будет 
	оступать полностью и прижиматься к противоположному краю.*/
}
/* Тут важно понимать что здесь центрируется блочный объект (строчный объект центрируется с помощью свойства text-align и его значений и опять же центрируется все что находится 
внутри объекта кот. применяюся свойства), с блочным объектом мы влияем на сам объект, то есть мы указывая этот параметр центрируем сам объект к кот. этот параментр применяется.  */
/*
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Центрировать блок если слева и справа отступы разные - там можно использовать конструкцию со вложенностью, то есть у нас есть родитель, мы его центрируем, внутри этого родителя у нас
есть блок и родителю мы можем задать padding сдвинув дочерний блок, и тогда у нас получится ассиметрия.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


max-width  (ограничение)
Устанавливает максимальную ширину блочных 
и блочно-строчных тегов (Это значит что объект не будет шире чем 700px, но может быть уже. Если он поподает в ситуацию где родитель уже чем 700px 
то он будет подстраиваться под него, то есть width у него все еще auto но максимальная ширина у него ограниченая на уровне 700px).
Ограничение может быть так же в %, соответственно 50% он будет не шире чем 50%, но это тоже самое что и width:50%;  потому что процент и ширина относительная от ширины родителя, 
по этому тут у нас разници никакой нет, но как раз ограничение в пиксельных процентах очень популярна.*/
block {
	/* Если у нас будет жесткое ограничение ширины, если наш объект попадет в ситуацию когда родитель уже -  мы поламаем верстку, у нас будет горизонтальный скрол. */
	width: 700px;
	margin: 0 auto;
	/* Но если мы ограничим объект по ширине с помощью max-width и если объект попадает в условия где родитель уже,  у нас никакого горизонтального скрола не появится
	объект наш начнет сжиматься под родителя. По этому где вам хочется указать width, возможно вам стоит указать max-width, тем самым обезопасив свою верстку */
	max-width: 700px;
	margin: 0px auto;
}

/* min-width работает на оборот Изначально наш объект на всю ширину,
как он и был,
но при попадании в условие где ширина родителя меньше чем указанное здесь значение,
мы как раз получим горизонтальный скрол и объект не будет меньше чем указанное значение,
больше может быть,
меньше нет. Устанавливает минимальную ширину блочных и блочно-строчных тегов */
.block {
	max-width: 700px;
	margin: 0px auto;
}

/*
height:
Устанавливает высоту блочных и блочно-строчных тегов
Свойство не наследуется.
Поскольку мы установили box-sizing: border-box; то внутренние отступы будут включаться в этот размер, то есть высота объекта будет 500px
включая отступы, то есть если укзали height 500px значит блок будет 500px.
height:100px;
height:10%;

min-height
Установит минимальное значение. То есть если текста будет больше, то блок будет увеличиваться, но объект не станет высотой меньше чем указаный. 
Свойство не наследуется.

max-height
Действует на оборот. Объект может быть меньше, но если контента станет больше то объект не увеличится больше чем по высоте (на пример 300px если указали max-height: 300px;
и текст у нас вылезет за пределы объекта.)
Свойство не наследуется.
*/

.block {
	height: 500px;
}

/*
overflow 
Оно управляет поведением контента за пределами объекта. 
Управляет отображением содержания блочного элемента
visible - Отображается все содержание элемента, даже за пределами установленной высоты и ширины. 
hidden - Отображается только область внутри элемента, остальное будет скрыто.
scroll - Всегда добавляются полосы прокрутки.
auto - Полосы прокрутки добавляются только при необходимости. Он появляется тогда когда он нужен. Контент не помещается - появляется скрол, но если контента будет мало - скрол
пропадет и это у нас будет самый обычный блок.
Самые используемые это hidden и auto.
*/

.block {
	max-height: 300px;
	overflow: hidden;
	/* Объект скроется. Мы видим что объект долез до нижней границы(падинг не учитывается, контент пробъет падинг - будет виден на месте где должен быть падинг, но не вылезет
	 за пределы самого блока). overflow: hidden; скрывает все что за пределами границ объекта. */
	overflow: scroll; /* У нас принудительно появится скрол. Даже при этом значении у нас будут поля вертикальные и горизонтальные, у нас поля скрол будут даже когда они нам не нужны, то есть когда контента 
		 мало и объект вообще меньше.*/
}

/*
https://www.youtube.com/watch?v=DxgKWsDurdE 1:49:40

display:
Многоцелевое свойство, которое определяет, как элемент должен быть показан в документе.
Свойство не наследуется.

block - Элемент показывается как блочный. Применение этого значения для встроенных элементов, например тега <span>, заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого. 											
inline - Элемент отображается как встроенный. Использование блочных тегов, таких как <div> и <p>, автоматически создает перенос и показывает содержимое этих тегов с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, где окончился предыдущий элемент. 											
inline - block - Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно встроенному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде тега <img>). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как встроенный. 											
none - Временно удаляет элемент из документа. Занимаемое им место не резервируется и веб-страница формируется так, словно элемента и не было. 
*/
/* Для inline width, max-width, min-width, height, max-height, min-height, overflow вообще не работают. */
/* Картинка это inline - block, строчного в нем то что если мы дальше напишем какой то текст, он выстроется в строку с этой картинкой, то есть текст не начнется с новой строки, 
а будет стараться выстроится с ней в одну линию. А блочного в этом объекте то что на картинку будут влиять вышеперечисленные свойства(width, max-width, min-width, height, max-height, min-height, overflow)*/
.link {
	font-size: 80px;
	color: red; /*  ссылка цвет не неследует */
	padding: 0px 0px 20px 0px; /* Этот отступ тоже будет ссылкой потому что он внутренний, он отступил от края ссылки внутрь, он подвинул текст ссылки(анкор) вверх, по этому так лучше не делать */
	margin: 0px 0px 100px 0px;
	display: inline-block; /* мы для ссылки указываем именно inline-block, а не 	display: block; Если мы укажем display: block то весь блочный объект он по умолчанию займет 
всю ширину родителя и ссылка у нас будет даже где заканчивается ее надпись, а нам не надо что бы пользователь жал на пустое место, а на саму ссылку. А inline-block
блочно-строчный объект он занимает по ширине только ширину контента, но при этом на него сработают отступы внешние-внутрение и ширина высота и макс/мин ширина высота. */
	display: inline; /* По умолчанию */
}

.header {
	/* По умолчанию */
	display: block;
}
.image {
	/* По умолчанию */
	display: inline-block; /* на картинку будут действовать оступы, ширина и высота, максимальная ширина и высота */
	/* что бы картинка пропорционально сжималась, height: лучше убрать оставить только ширину и теперь она будет пропорционально изменять размеры */
}
.text {
	display: none; /* Сейчас современные уже SEO технологии, поисковые роботы, они когда находят  display: none; в css то они не воспринимают этот объект */
	font-size: 50px;
}
