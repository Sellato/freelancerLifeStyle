@use "sass:math";

// Подключение миксинов ===========================================================================================================================================================================================================================================================================
@import "base/mixins";

// Подключение шрифтов ===========================================================================================================================================================================================================================================================================
//&display=swap - добавить при подключении через плагин
@import "base/fonts";

// Подключение иконочных шрифтов ==============================================================================================================================================================================================================================================================================
@import "base/icons";

// Шрифт по умолчанию ==============================================================================================================================================================================================================================================================================
$fontFamily: "";
$fontSize: rem(16); // где 14(px) - размер шрифта по умолчанию из макета

// НАСТРОЙКИ ===============================================================================================================================================================================================================================================================================================
// Минимальная ширина страницы
$minWidth: 320;
// Ширина полотна (макета)
$maxWidth: 1920;
// Ширина ограничивающего контейнера (0 = нет ограничения)
$maxWidthContainer: 1170;
// Общий отступ у контейнера
// (30 = по 15px слева и справа, 0 = нет отступа)
$containerPadding: 30;

// Тип адаптива:
// 1 = отзывчивость (у контейнера нет брейкпоинтов),
// 2 = по брейк-поинтам (контейнер меняет свою ширину по брейк-поинтам)
$responsiveType: 1;

// Ширина страбатывания первого брейкпоинта
$containerWidth: $maxWidthContainer + $containerPadding;

// Брейк-поинты
$pc: em($containerWidth); // ПК, ноутбуки, некоторые планшеты в горизонтальном положении
$tablet: em(991.98); // Планшеты, некоторые телефоны в горизонтальном положении
$mobile: em(767.98); // Телефоны L
$mobileSmall: em(479.98); // Телефоны S

// Основной цвет шрифта
$mainColor: #fff;

// Обнуление и общие параметры ============================================================================================================================================================================================== =============================================================================================== ===============================================================================================
@import "base/null";

body {
	color: $mainColor;
	background-color: #333;
	// Скролл заблокирован
	.lock & {
		overflow: hidden;
		touch-action: none;
	}
}

// Оболочка ============================================================================================================================================================================================================================================================================================================================================================================================================================================
.wrapper {
	min-height: 100%;
	display: flex;
	flex-direction: column;
	overflow: hidden;
	// Сайт загружен
	.loaded & {
	}
	// Прижимаем footer
	> main {
		flex: 1 1 auto;
	}
	// Фикс для слайдеров
	> * {
		min-width: 0;
	}
}

// Ограничивающий контейнер ======================================================================================================================================================================================================================

/*
(i) Стили будут применяться ко 
всем классам содержащим *__container
Например header__container, main__container и т.д.
Снипет (HTML): cnt
*/
@if ($responsiveType==1) {
	// Отзывчивая
	[class*="__container"] {
		@if ($maxWidthContainer>0) {
			max-width: rem($maxWidthContainer);
			box-sizing: content-box;
			margin: 0 auto;
		}
		@if ($containerPadding>0) {
			padding: 0 rem(math.div($containerPadding, 2));
		}
	}
} @else {
	// По брейк-поинтам
	[class*="__container"] {
		margin: 0 auto;
		@if ($maxWidthContainer>0) {
			max-width: rem($maxWidthContainer);
			box-sizing: content-box;
		} @else {
			@if ($containerPadding>0) {
				padding: 0 rem(math.div($containerPadding, 2));
			}
		}
		@media (max-width: $pc) {
			max-width: rem(970);
		}
		@media (max-width: $tablet) {
			max-width: rem(750);
		}
		@media (max-width: $mobile) {
			max-width: none;
			@if ($containerPadding>0 and $maxWidthContainer>0) {
				padding: 0 rem(math.div($containerPadding, 2));
			}
		}
	}
}

// Подключение базовых стилей, шаблонов (заготовок) и вспомагательных классов
// Для подключения/отключения конкретных стилей смотри base.scss
@import "base";

// Подключение стилей отдельных блоков
@import "header";
@import "footer";

// Подключение стилей отдельных страниц
@import "home";

.block {
	padding: 50px 0;
	// .block__title
	&__title {
		font-size: rem(20);
		text-transform: uppercase;
		&:not(:last-child) {
			margin-bottom: em(20, 20);
		}
	}
	.block__items &__items {
		display: grid; /* все наши некогда строчные теги превращаются фактически в блочные по умолчанию, и выстраиваются друг за другом. */
		// Грид может работать сразу в двух линиях - и горизонтальной и вертикальной одновременно что естественно увеличивает возможности вдвое.
		grid-template-columns: repeat(3, 1fr);
		/*grid-template: ;  сокращенная запись где мы указываем сразу и одну и вторую.  */
		grid-auto-rows: 1fr;
		gap: 20px;
		@media (max-width: $tablet) {
			grid-template-columns: repeat(2, 1fr);
		}
		@media (max-width: em(560)) {
			grid-template-columns: repeat(1, 1fr);
		}
	}
}
.item {
	background-color: #666;
	padding: 20px;
	display: flex;
	flex-direction: column;
	gap: 15px;

	display: grid;
	grid-template-rows: auto 1fr;
	gap: 15px;

	.item__image-ibg &__image-ibg {
		padding-bottom: percent(250, 300);
	}
	// .item__body
	&__body {
		flex: 1 1 auto;

		display: grid;
		justify-items: start;
		grid-template-rows: auto 1fr;
		gap: 10px;
	}
	// .item__title
	&__title {
		text-transform: uppercase;
	}
	// .item__name
	&__name {
	}
	// .item__text
	&__text {
	}
	// .item__link
	&__link {
	}
}
// =========================================================
//  https://www.youtube.com/watch?v=h3GQW4mBoB0 c 1:53:00 (лучше посмотреть)
.grid {
	display: grid;
	// Строим колонки
	grid-template-columns: repeat(12, 1fr);

	grid-template-columns: repeat(3, 200px); /* repeat позволяет нам просто продублировать значения. repeat адекватен только тогда когда мы хотим все колонки задать одного размера. (3, 200px) - теперь у нас трех-колоночная система и каждая колонка будет 200px */
	grid-template-columns: repeat(3, 33.333%); /* и эти 3 колонки будут равнозначны, их будет 3, и каждая будет занимать треть.  Соответственно ряды будут выстраиваться автоматически.*/
	grid-template-columns: repeat(3, 1fr); /* 1fr(указываем что все 3 колонки равнозначные) - это единица специально предназначена для модуля grid. Соответственно если мы каждой колонке задаем одиниковый фрагмент  1fr, то они будут фактически стараться занять всю ширину. Соответственно когда мы указываем (3, 1fr) построй нам 3 колонки и каждая из них будет стараться занять всю ширину 
	то у нас получятся 3 абсолютно одинаковых колонки, потому что они равнозначны, каждая пытается занять всю ширину родителя.  И эфект такой же как от процентов но круче потому что мы можем использовать gap.*/
	gap: 15px; /* если мы хотим использовать отступ gap то проценты не подходят и мы используем fr */
	// column-gap: ;
	// row-gap: ;

	grid-template-columns: 200px 1fr 200px; /* первая колонка будет 200px, вторая колонка будет всегда на всю ширину пространства где она будет помещена. И третяя колонка будет 200px. */
	grid-auto-rows: 1fr; /* это свойство которому мы задаем размер рядов которые не явны, которые создаются автоматически. Мы задаем размер рядам которые создаются автоматически, и задаем размер 1fr, то есть они все одинаковые. Это значит что стоит нам заменить высоту одного ряда как все остальные ряды тоже изменять высоту. */

	// Как добиться того что бы колонки стали лишними?
	// grid-auto-flow: ;говорит гриду как ему выстраивать все без явной сетки
	grid-auto-flow: column; /* заставить наш грид все элементы выстраивать в ряд сколько бы их не было. */
	grid-auto-flow: row; /* будет выстраивать по одному в ряд(в колонку). Это у нас по умолчанию.*/

	// Это автоматическая сеть, сколько ей будет хватать места, столько будет помещаться колонок, колонки будут стоиться автоматически.
	// Как только колонка достигает ширины которую мы указали как минимальную (200px) - сеть перестраивается и появляются ряды. Фактически
	// это автоматический адаптив сетки с указанием минимально-возможной ширины.
	grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* 1fr отвечает здесь что бы по умолчанию колонка всегда старалась расширяться и заполнять все текущее пространство.  */
	// auto-fit отвечает за то что бы колонки заполнялись автоматически, но там есть 2 свойства -  auto-fit и auto-fill. auto-fill - не будет растягивать колонки на все пространство, а просто их оставит(то есть они будут 200px по минимальной ширине контента).
	// Чаще всего используется auto-fit, потому что мы хотим что бы у нас были отзывчивые колонки.

	align-items: start; /* (управляет содержимым этих ячеек по вертикали). Работает так же только здесь нету приставки flex */
	align-content: start; /* (управляет сеткой (если есть куда, есть место) по вертикали). */
	align-items: end; /* .когда у нас ряд выше чем контент align-items будет прибивать контент  внутри структуры которую мы построили - к низу, к верху. */
	justify-content: space-between; /* (управляет сеткой (если есть куда, есть место) по горизонтали) управляет простым пространством если оно есть, но не должно быть указано 1fr. Оно работаеть только если у нас есть свободное пространство.*/
	justify-items: end; /* (управляет по горизонтали содержимым колонок) управляем перемещением контента внутри колонки. */
	// .grid__item
	&__item {
		padding: 15px;
		border-radius: rem(15);
		grid-template-columns: 120px 20% 1fr 300px 15%; /* Этой записью мы конструируем явную сетку - в данном случае - колонки.  Это размеры каждой колонки слева-направо. 20% будет относительно ширине родителя  .grid. При адаптиве те процентные значения будут перестраиваться, а пиксельные будут фиксированые.  */
		// Важное отличие грида от флекса - грид строит конструкцию в не зависимости от самих элементов. То есть конструкция построена без элементов - нам не нужны оболочки для того что бы построить конструкцию, конструкцию мы стороим css свойствами.
		grid-template-rows: 50px 100px 40%; /* объяснение https://www.youtube.com/watch?v=h3GQW4mBoB0 с 17:00 */
		// .grid__item_v1

		&_v1 {
			background-color: #794f45;
			grid-column: span 4; /* первая ячейка объеденила со следующими тремя ячейками. */
		}
		// .grid__item_v2
		&_v2 {
			background-color: #7a956b;
			grid-column: span 6;
			grid-row: span 2;
		}
		// .grid__item_v3
		&_v3 {
			background-color: #77608d;
			grid-column: span 6;
		}
		// .grid__item_v4
		&_v4 {
			background-color: rosybrown;
			grid-column: span 3;
		}
		@media (max-width: $tablet) {
			&:nth-child(3) {
				display: none;
			}
			&_v1 {
				grid-column: span 6;
				order: 1;
			}
			&_v2 {
				order: 2;
				grid-column: span 8;
			}
			&_v3 {
				order: 4;
				//grid-column: span 8;
				grid-column-start: 4;
				grid-column-end: 13;
			}
			&_v4 {
				order: 3;
				grid-column: span 4;
			}
		}
		@media (max-width: $mobile) {
			&_v1 {
			}
			&_v2 {
				grid-column: span 10;
			}
			&_v3 {
				order: 4;
				//grid-column: span 8;
				grid-column-start: 3;
				grid-column-end: 13;
			}
			&_v4 {
				order: 3;
				grid-column: span 6;
			}
		}
		@media (max-width: $mobileSmall) {
			grid-column-start: 1;
			grid-column-end: 13;
		}
	}
}
// ==========================================
/*
aside
 https://www.youtube.com/watch?v=h3GQW4mBoB0
на 1:10:25 */
.page {
	display: grid;
	grid-template-columns: 250px 1fr;
	grid-template-rows: 1fr auto;

	grid-template-areas: "sidebar content" "slider slider";

	padding: 15px;
	gap: 20px;
}
.sidebar {
	background-color: #794f45;
	grid-area: sidebar;
}
.menu {
	// .menu__list
	&__list {
	}
	// .menu__item
	&__item {
	}
	// .menu__link
	&__link {
	}
}
.content {
	grid-area: content;
}
.slider {
	grid-area: slider;
	background-color: #77608d;
	display: flex;
	justify-content: space-between;
	// .slider__slide
	&__slide {
	}
}
