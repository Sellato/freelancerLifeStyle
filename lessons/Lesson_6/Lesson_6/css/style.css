/* 
&display=swap
&subset=cyrillic-ext 
*/

/* ОБНУЛЕНИЕ СТИЛЕЙ */
*,
*::before,
*::after {
	margin: 0;
	padding: 0;
	border: 0;
	box-sizing: border-box;
}
li {
	list-style: none;
}
a,
a:visited {
	text-decoration: none;
}
a:hover {
	text-decoration: none;
}
h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: inherit;
	font-size: inherit;
}
img {
	vertical-align: top;
}
html,
body {
	height: 100%;
}
html {
	font-size: 16px; /* по умолчанию */
}
body {
	line-height: 1;
}
.wrapper {
	min-height: 100%;
	overflow: hidden;
	padding: 20px;
}
/* ------------------------------ */
/* .block {
	background-color: rgba(119, 96, 141, 1);
	width: 200px;
	height: 200px;
	margin: 0px 0px 20px 0px;
	padding: 15px;
	border-radius: 50%;
	box-shadow: 10px 10px 10px #000;
}
.inline {
	background-color: #7a956b;
	border: 5px solid #000;
} */

/*
border
Универсальное свойство border позволяет одновременно 
установить толщину, 
стиль и цвет границы вокруг элемента.
border: 1px solid #000; (размер стиль цвет)
Основные стили -solid dotted dashed double

Синтаксис общего свойства:
border: толщина_линии стиль_линии цвет_линии

При режиме border-box; с border проиходит следуещее, что ширина объекта включает в себя border в том числе. То есть если у нас объект width: 200px; 
то он будет 200px вне зависимости от того какой у нас  border. Фактически border работает в данном случае точно так же как и padding. Фактически эта граница (border) она 
оттаокивает контент внутрь от границ блока, тоже самое происходит когда мы задаем padding. Если мы зададим и border и padding то  у нас будет как бы borde, а потом еще padding от этой
границы, то есть контент сузится 2 раза. То есть при подсчете размера объекта border включен в этот размер, то есть  при width: 200px; padding: 15px;(то есть по слева-справа 15px-15px)
a border: 5px solid red;(слева-справа 5px-5px) то 15+15+5+5=40px итого ширина фактическая контента будет 160px, а ширина блока останется 200px как мы и задали, 
то есть border действует по сути как padding.

Когда есть какой то фон то если у нас цвет границы прозрачный (border: 5px solid rgba(0, 0, 0, 0.2);) то мы будем видеть этот фон, если мы сделаем полностью
прозрачным  rgba(0, 0, 0, 0); border то его от padding уже ничем не отличить. Прозрачность(прозрачный цвет) у border штука важная,  ее еще можно задать 
написав transparent(означает прозрачный, бесцветный) вместо цвета. Если убрать padding то внутренний отступ будет реализован с помощью border.

Использование border для строчных объектов не целесобразно совсем.
Border может наследовать color.  То есть если у нас у объекта есть уже color, то мы в border можем не писать еще раз color(и это как бы баг). По этому в hover нам нужно будет поменять просто color,
а не весь border. И теперь у нас будет меняться не только цвет текста, но и цвет границы.

Как правило в border чаще всего используем px. 
*/
/*
outline
Это внешняя граница (внешняя линия - она выступает за пределы блока(она опаясывет вокруг но при этом она никак не влияет на его размер - линия outline не имеет тела, 
она как призрак, она не влияет на окружающие объекты, она не сможет оттолкнуть от себя другой объект, блок нижний все равно прижат к блоку вверхнему(кот, с outline) 
outline не толкнула блок вниз, это просто как декоративная ленточка вокруг блока)) 
во всех смыслах и есть ряд отличий от border: 
- Во первых outline может иметь только общую запись, то есть outline нельзя задать для какой то одной стороны. Мы только можем написать outline 
	с параметрами - синтаксис точно такой же как и у border (толщина_линии стиль_линии цвет_линии) но мы не можем написать outline-top - такого свойства не существует.

outline используется - им можно заменить border когда нам нужен декоративный элемент (граница в 1px) и как удобно при hover убирать и не нужно задавать 2 border, прозрачность border.
outline в себе несет более важную задачу и эта задача связана с доступностью
---------------------------------------------------------------------------------
У строчного объекта его line-hight как и outline не имеют тела.
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
outline не должен работать с бордер радиусом.
---------------------------------------------------------------------------------
Универсальное свойство, одновременно устанавливающее цвет, 
стиль и толщину внешней границы на всех четырех сторонах элемента. 
В отличие от линии, задаваемой через border, свойство outline 
не влияет на положение блока и его ширину. 
Также нельзя задать параметры линии на отдельных сторонах элемента, 
outline применяется сразу ко всем четырём сторонам.
*/

/*
border-radius
Предназначен для скругления углов, мы указываем в px,% и других единицах.
Нам не обязательно использовать border что бы скруглить углы(что бы использовать border-radius), они не работают в паре, он скругляет углы для блочного элемента.
потому что на строчном он будет работать не адекватно - он будет круглить начало и конец строки  
Устанавливает радиус скругления уголков блока.
border-radius:50%; - круг, если объект у нас квадратный(width:200px; height:200px;). 
Можно использовать вместе с overflow: hidden;

border-radius: 20px 10px 30px 40px; закругляются с вверх-лева - вверх-права - низ-лева - низ-права

border-radius: 20px 10px 30px 40px / 10px 20px 50px 6px; такая запись позволяет нам круглить уже закругленный угл 
и делать более не стандартные вещи. https://9elements.github.io/fancy-border-radius/

border-radius довольно ширико используется сегодня в дизайне, и с помощью него можно избавиться от выгрузки изображений, а делать их самостоятельно. 

*/

/*
box-shadow
Добавляет тень к элементу(блоку).
box-shadow: сдвиг_по_гориз сдвиг_по_верт радиус расстояние.
- box-shadow: 1px 1px  10px 10px red; добавляется 4-ый параметр за размер(а третий параметр это размытость).
- box-shadow задается только для прямоугольной области, не для строчной.
- box-shadow работает с border-radius - то есть тень будет совпадать с закругленостью объекта.
- box-shadow не работает с прозрачной картинкой.
Флаг inset для установки внутренней тени - box-shadow: inset 0px 0px  20px 20px red, 0px 0px  20px 20px black; - внутрення тень inset 0px 0px  20px 20px red, внешняя тень , 0px 0px  20px 20px black;
Можно добавить много теней. На тень влияет свойство border-radius.
filter: drop-shadow(0px 0px 10px #77608d); - редко используется.
*/
/* 
Что бы сделать размытым круг
width:200px;
height:200px;
background-color:yellow;
border-radius:50%;
box-shadow: 0px 0px  20px 20px red; и получим фактически размытый круг */
/*
==============================================================
Не стоит путать прозрачный цвет, opacity, display: none;  , visibility.
1) прозрачный цвет - 	background-color: rgba(119, 96, 141, 0.5); - цвет фона у этого объекта стал на 50% прозрачным, текст, другой контент в этом объекта вообще никак не задействован, он такой же как и был, но сам цвет фона стал полупрозрачным на определенный указатель.
То же ситуация и если для текста color: rgba(119, 96, 141, 0.5); 
2) opacity -  это значит что весь блок с его всеми фонами, текстами, все его дочерние элементы, все что входит внутри него будет в данном случае opacity:0.5; на 50% прозрачным. opacity:0; сделает объект полностью прозрачным. В чем разница? Этот объект просто 
прозрачен, мы его не видим, видим то что за ним, потому что он прозрачен, как невидимка, но мы до сих пор можем с ним работать(место осталось), просто у него полная прозрачность, анимировать.
3)display: none;  - полностью убирает объект, место его пропадает и место его занимаю объекты кот. ниже идут по коду, и мы уже с этим объектом не можем взаимодействовать.
4)visibility - свойство по умолчанию которое visible. Управляет отображение объект. Если мы поменяем visible на hidden то объект исчезнет на подобии как исчезает объект от opacity:0;, потому что место он за собой свое хранит, не так как display: none; 
visibility: hidden; просто убирает его видимость, но не надо путать с opacity:0;, потому что мы теперь не можем взаимодействовать с объектом, с ним нельзя взаимодействовать при visibility: hidden; на нем не будет рабоать свойство hover и т.д.
opacity и visibility используются вместе когда нам нужно объект скрыть, а потом показать(допустим плавно). Используются вместе потому что парамент visibility, тот же display они не анимируются, на эти свойства не работают плавный переход, а на свойство opacity работают,
по этому если мы хотим изначально объект скрыть, а потом его показать, то нам будет не обходимо использовать оба этих свойства. 

- То есть когда нам нужно скрыть объект но с ним взаимодействовать - нам нужен opacity:0;
- если нам нужно скрыть объект что бы нельзы было с ним взаимодейтсвовать - мы должны работать с visibility: hidden; 
- если нам нужно скрыть объект что б с ним нельзя было взаимодействовать но при hover показать , тогда нам нужно этот hover интегрировать не на сам объект на котором visibility: hidden;, 
   а на его родителя и уже по родительскому пути обращаться к дочернему и возращать ему visibility: visible; и opacity:1; 
==============================================================
opacity
opacity делает объект полупрозрачным. Фактически opacity управляет прозрачностью, не прозрачностью и полупрозрачностью объекта.
Значением является цифра от 0 до 1.
Все объекты по умолчанию полностью не прозрачны и свойство opacity помогает при не обходимости менять это значение.

Определяет уровень прозрачности элемента.
Отличие opacity:0; от display:none; в том что блок 
не убирается из верстки а только становиться прозрачным, 
то есть занимаемое им место остается. Так же, 
с прозрачными элементами все еще можно взаимодействовать, 
например кликать по ссылкам.
*/
/*
visibility
Предназначен для отображения или скрытия элемента.
Отличие visibility: hidden; от display:none; в том что блок 
не убирается из верстки а только скрывается, 
то есть занимаемое им место остается.
Отличие visibility: hidden; от opacity:0;
 в том что блок скрывается и взаимодействовать с ним нельзя.
*/
/*
.text-link {
	color: green;
	border-bottom: 2px dotted;
	display: inline-block;
}
.text-link:hover {
	color: red;
}
*/
/*
.link {
	display: inline-block;
	background-color: #794f45;
	display: inline-block;
	color: #fff;
	padding: 15px;
	border: 5px solid red;
}
.link:hover {
	border: 5px solid transparent; https://www.youtube.com/watch?v=IhtE_y5Lwh8 с 58:00
}
*/
/* -------------------------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------------------------- */
/* Объяснение домашки #5 */
/* 
.block {
	padding: 20px;
	margin: 0px 0px 30px 0px;
}
.block__title {
	font-weight: 700;
	font-size: 30px;
	margin: 0px 0px 20px 0px;
}
.block__body {
}
*/
/*
vertical-align - выравнивает строчные  ( https://www.youtube.com/watch?v=IhtE_y5Lwh8   с 7:00)
и блочно-строчные объекты по вертикали
top - по верху
middle - по центру
bottom - по низу
*/

/*
Схлопывание внешнего отступа происходит только с блочными объектами (горизонтального схлопывания нет(слева справа), только вертикальное. 
margin слева и справа сумируются, а вот верх и низ нет.
Для блочно-строчных объектов вообще не работает схлопывание, только с блочными объектами.  
*/

/* ------------------------------------------------- */
/* margin: 0 auto; работает только при display: inline-block;, только display: block; */
/* ------------------------------------------------- */

/* Фантомные отступы - https://www.youtube.com/watch?v=IhtE_y5Lwh8 с 15:00 */
/* Здесь есть отступ кот. не существует(мы его нигде не задавали). Такая проблема появляется когда работаем с 	display: inline-block; */
.block__texts {
	font-size: 0;
}

.block__items {
	font-size: 0; /* ;задаем родителю */
}
.block__item {
	display: inline-block;
	max-width: 200px;
	max-height: 200px;
	overflow: hidden;
	padding: 15px;
	background-color: #794f45;
	color: #fff;
	font-size: 20px; /* и задать дочернему тот размер кот. по макету. */
	vertical-align: middle;
	margin: 0 auto; /* это здесь работать не будет */
}
/* 
.span {
	display: block;
}
.link {
	margin: 0px 0px 20px 0px;
	display: inline-block;
}
.text {
	display: inline-block;
	max-width: 100px;
	background-color: #77608d;
	padding: 10px;
	font-size: 16px;
	margin: 0px 30px 0px 0px;
}

.block__one,
.block__two {
	padding: 30px;
	color: #fff;
	font-size: 24px;
}

.block__one {
	background-color: #794f45;
}
.block__two {
	background-color: #7a956b;
	margin: -50px 0px 0px 0px;
}

.big-text {
	max-height: 200px;
	background-color: #77608d;
	padding: 30px;
	display: block;
	font-size: 30px;
	color: #fff;
	line-height: 120%;
	overflow: auto;
}
*/
